<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SOLID Design Principles: Advanced Guide for Senior Developers</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: white;
            box-shadow: 0 0 30px rgba(0,0,0,0.1);
            border-radius: 15px;
            margin-top: 20px;
            margin-bottom: 20px;
        }

        .header {
            text-align: center;
            padding: 40px 0;
            background: linear-gradient(135deg, #2c3e50, #3498db);
            color: white;
            border-radius: 15px 15px 0 0;
            margin: -20px -20px 40px -20px;
        }

        .header h1 {
            font-size: 3em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .subtitle {
            font-size: 1.3em;
            opacity: 0.9;
            font-weight: 300;
        }

        .badge {
            display: inline-block;
            background: #e74c3c;
            color: white;
            padding: 8px 16px;
            border-radius: 25px;
            font-size: 0.9em;
            margin-top: 15px;
            font-weight: 500;
        }

        .toc {
            background: #f8f9fa;
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 40px;
            border-left: 5px solid #3498db;
        }

        .toc h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.8em;
        }

        .toc ul {
            list-style: none;
            columns: 2;
            column-gap: 40px;
        }

        .toc li {
            margin-bottom: 12px;
            padding-left: 20px;
            position: relative;
        }

        .toc li:before {
            content: "▶";
            position: absolute;
            left: 0;
            color: #3498db;
            font-size: 0.8em;
        }

        .toc a {
            color: #2c3e50;
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s ease;
        }

        .toc a:hover {
            color: #3498db;
        }

        .section {
            margin-bottom: 60px;
            scroll-margin-top: 100px;
        }

        .section-header {
            background: linear-gradient(135deg, #34495e, #2c3e50);
            color: white;
            padding: 25px 30px;
            border-radius: 10px;
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
        }

        .section-header::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grain" width="100" height="100" patternUnits="userSpaceOnUse"><circle cx="25" cy="25" r="1" fill="rgba(255,255,255,0.1)"/><circle cx="75" cy="75" r="1" fill="rgba(255,255,255,0.1)"/></pattern></defs><rect width="100" height="100" fill="url(%23grain)"/></svg>');
            opacity: 0.1;
        }

        .section-header h2 {
            font-size: 2.5em;
            margin-bottom: 10px;
            position: relative;
            z-index: 1;
        }

        .section-header .principle-letter {
            display: inline-block;
            width: 60px;
            height: 60px;
            background: #e74c3c;
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 60px;
            font-size: 1.5em;
            font-weight: bold;
            margin-right: 20px;
            vertical-align: middle;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .section-header .description {
            font-size: 1.2em;
            opacity: 0.9;
            position: relative;
            z-index: 1;
        }

        .principle-intro {
            background: #ecf0f1;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 30px;
            border-left: 5px solid #3498db;
        }

        .principle-intro h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.4em;
        }

        .principle-intro .core-concept {
            background: #3498db;
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-weight: 500;
            text-align: center;
            font-size: 1.1em;
        }

        .subsection {
            margin-bottom: 40px;
        }

        .subsection h3 {
            color: #2c3e50;
            font-size: 1.6em;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #ecf0f1;
        }

        .subsection h4 {
            color: #34495e;
            font-size: 1.3em;
            margin: 25px 0 15px 0;
        }

        .code-block {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 25px;
            border-radius: 10px;
            margin: 20px 0;
            overflow-x: auto;
            position: relative;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .code-block::before {
            content: "Java";
            position: absolute;
            top: 10px;
            right: 15px;
            background: #e74c3c;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: 500;
        }

        .code-block pre {
            margin: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .code-block code {
            font-family: 'Courier New', Consolas, monospace;
            font-size: 0.9em;
            line-height: 1.5;
        }

        .highlight {
            background: #f39c12;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 500;
        }

        .example-box {
            background: #d5f4e6;
            border: 1px solid #27ae60;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }

        .example-box h4 {
            color: #27ae60;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .violation-box {
            background: #fde8e8;
            border: 1px solid #e74c3c;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }

        .violation-box h4 {
            color: #e74c3c;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .key-points {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 10px;
            padding: 20px;
            margin: 25px 0;
        }

        .key-points h4 {
            color: #856404;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .key-points ul {
            margin-left: 20px;
        }

        .key-points li {
            margin-bottom: 8px;
        }

        .benefits-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .benefit-card {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 10px;
            border-left: 5px solid #3498db;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .benefit-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
        }

        .benefit-card h4 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .summary-section {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 40px;
            border-radius: 15px;
            margin-top: 60px;
            text-align: center;
        }

        .summary-section h2 {
            font-size: 2.5em;
            margin-bottom: 20px;
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 30px;
            margin-top: 40px;
        }

        .summary-card {
            background: rgba(255,255,255,0.1);
            padding: 25px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .summary-card h3 {
            font-size: 1.5em;
            margin-bottom: 15px;
        }

        .navigation {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(44, 62, 80, 0.9);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            z-index: 1000;
        }

        .navigation a {
            display: block;
            color: white;
            text-decoration: none;
            padding: 8px 15px;
            border-radius: 5px;
            margin-bottom: 5px;
            transition: background 0.3s ease;
            font-size: 0.9em;
        }

        .navigation a:hover {
            background: rgba(52, 152, 219, 0.8);
        }

        .scroll-indicator {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: rgba(52, 152, 219, 0.3);
            z-index: 1001;
        }

        .scroll-progress {
            height: 100%;
            background: #3498db;
            width: 0%;
            transition: width 0.1s ease;
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
                padding: 15px;
            }

            .header h1 {
                font-size: 2em;
            }

            .toc ul {
                columns: 1;
            }

            .navigation {
                display: none;
            }

            .benefits-grid {
                grid-template-columns: 1fr;
            }

            .summary-grid {
                grid-template-columns: 1fr;
            }
        }

        .principle-overview {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 40px 0;
        }

        .principle-card {
            background: white;
            border: 2px solid #ecf0f1;
            border-radius: 15px;
            padding: 25px;
            text-align: center;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .principle-card:hover {
            border-color: #3498db;
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .principle-card::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #3498db, #9b59b6);
        }

        .principle-card .letter {
            display: inline-block;
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, #3498db, #9b59b6);
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 80px;
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 20px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.1);
        }

        .principle-card h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .principle-card p {
            color: #7f8c8d;
            font-size: 0.95em;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <div class="scroll-indicator">
        <div class="scroll-progress" id="scrollProgress"></div>
    </div>

    <div class="navigation" id="navigation">
        <a href="#introduction">Introduction</a>
        <a href="#srp">SRP</a>
        <a href="#ocp">OCP</a>
        <a href="#lsp">LSP</a>
        <a href="#isp">ISP</a>
        <a href="#dip">DIP</a>
        <a href="#conclusion">Conclusion</a>
    </div>

    <div class="container">
        <div class="header">
            <h1>SOLID Design Principles</h1>
            <div class="subtitle">Advanced Guide for Senior Developers (15+ Years Experience)</div>
            <div class="badge">Enterprise Architecture & Design Patterns</div>
        </div>

        <div class="toc">
            <h2>📋 Table of Contents</h2>
            <ul>
                <li><a href="#introduction">Introduction: Beyond Basic SOLID</a></li>
                <li><a href="#principles-overview">SOLID Principles Overview</a></li>
                <li><a href="#srp">Single Responsibility Principle (SRP)</a></li>
                <li><a href="#ocp">Open/Closed Principle (OCP)</a></li>
                <li><a href="#lsp">Liskov Substitution Principle (LSP)</a></li>
                <li><a href="#isp">Interface Segregation Principle (ISP)</a></li>
                <li><a href="#dip">Dependency Inversion Principle (DIP)</a></li>
                <li><a href="#distributed-systems">SOLID in Distributed Systems</a></li>
                <li><a href="#testing-strategies">Testing Strategies</a></li>
                <li><a href="#performance">Performance Considerations</a></li>
                <li><a href="#anti-patterns">Anti-Patterns & Violations</a></li>
                <li><a href="#conclusion">Conclusion & Best Practices</a></li>
            </ul>
        </div>

        <section id="introduction" class="section">
            <div class="section-header">
                <h2>🚀 Introduction: Beyond Basic SOLID</h2>
                <div class="description">Understanding SOLID principles in complex enterprise environments</div>
            </div>

            <div class="principle-intro">
                <h3>Evolution of Understanding</h3>
                <p><strong>Junior Level:</strong> "Each class should do one thing"</p>
                <p><strong>Mid Level:</strong> "Classes should be cohesive and loosely coupled"</p>
                <p><strong>Senior Level:</strong> "SOLID principles define architectural boundaries and guide system evolution"</p>
                <p><strong>Architect Level:</strong> "SOLID principles balance technical excellence with business value and team dynamics"</p>
            </div>

            <div class="key-points">
                <h4>🎯 Modern Context Challenges</h4>
                <ul>
                    <li><strong>Microservices Architecture:</strong> Service boundaries, data consistency, distributed transactions</li>
                    <li><strong>Event-Driven Systems:</strong> Asynchronous processing, eventual consistency, event sourcing</li>
                    <li><strong>Cloud-Native Applications:</strong> Scalability, resilience patterns, infrastructure abstraction</li>
                    <li><strong>Domain-Driven Design:</strong> Bounded contexts, aggregates, ubiquitous language</li>
                    <li><strong>DevOps Integration:</strong> Continuous deployment, infrastructure as code, observability</li>
                </ul>
            </div>
        </section>

        <section id="principles-overview" class="section">
            <div class="section-header">
                <h2>📊 SOLID Principles Overview</h2>
                <div class="description">The five fundamental principles of object-oriented design</div>
            </div>

            <div class="principle-overview">
                <div class="principle-card">
                    <div class="letter">S</div>
                    <h3>Single Responsibility</h3>
                    <p>A class should have only one reason to change. Focus on cohesion around a single axis of change.</p>
                </div>
                <div class="principle-card">
                    <div class="letter">O</div>
                    <h3>Open/Closed</h3>
                    <p>Software entities should be open for extension but closed for modification. Enable growth without breaking existing code.</p>
                </div>
                <div class="principle-card">
                    <div class="letter">L</div>
                    <h3>Liskov Substitution</h3>
                    <p>Objects of a superclass should be replaceable with objects of its subclasses without breaking functionality.</p>
                </div>
                <div class="principle-card">
                    <div class="letter">I</div>
                    <h3>Interface Segregation</h3>
                    <p>Clients should not be forced to depend on interfaces they don't use. Create focused, client-centric interfaces.</p>
                </div>
                <div class="principle-card">
                    <div class="letter">D</div>
                    <h3>Dependency Inversion</h3>
                    <p>High-level modules should not depend on low-level modules. Both should depend on abstractions.</p>
                </div>
            </div>
        </section>

        <section id="srp" class="section">
            <div class="section-header">
                <span class="principle-letter">S</span>
                <div>
                    <h2>Single Responsibility Principle</h2>
                    <div class="description">Architectural Cohesion & Change Management</div>
                </div>
            </div>

            <div class="principle-intro">
                <h3>Advanced SRP Understanding</h3>
                <div class="core-concept">
                    SRP is fundamentally about <span class="highlight">cohesion around change</span>. 
                    It's not about limiting functionality but ensuring all functionality within a module 
                    changes for the same reason and at the same rate.
                </div>
            </div>

            <div class="subsection">
                <h3>1. Change Vector Analysis</h3>
                <p>Understanding different types of changes that can affect a class:</p>

                <div class="violation-box">
                    <h4>❌ SRP Violation - Multiple Change Vectors</h4>
                    <div class="code-block">
<pre><code>public class Order {
    // Financial data - changes with tax rules, pricing models
    private BigDecimal subtotal;
    private BigDecimal tax;
    private BigDecimal discount;
    
    // Operational data - changes with fulfillment processes
    private OrderStatus status;
    private LocalDateTime estimatedDelivery;
    private Address shippingAddress;
    
    // Audit data - changes with compliance requirements
    private LocalDateTime createdAt;
    private String createdBy;
    private List&lt;AuditEvent&gt; auditTrail;
    
    // Notification data - changes with communication preferences
    private List&lt;String&gt; notificationEmails;
    private NotificationPreference preferences;
    
    // This class has at least 4 distinct change vectors!
}</code></pre>
                    </div>
                </div>

                <div class="example-box">
                    <h4>✅ SRP-Compliant Decomposition</h4>
                    <div class="code-block">
<pre><code>// Core business entity - changes only with core business rules
public class Order {
    private final OrderId orderId;
    private final CustomerId customerId;
    private final List&lt;OrderLine&gt; orderLines;
    private final OrderMetadata metadata;
    
    public void addOrderLine(ProductId productId, Quantity quantity, Price price) {
        orderLines.add(new OrderLine(productId, quantity, price));
    }
    
    public Money calculateTotal(PricingPolicy pricingPolicy) {
        return pricingPolicy.calculateTotal(this.orderLines);
    }
}

// Financial concerns - changes with tax and pricing rules
public class OrderFinancials {
    private final OrderId orderId;
    private Money subtotal;
    private TaxCalculation tax;
    private DiscountApplication discount;
    
    public Money calculateFinalAmount(TaxPolicy taxPolicy, DiscountPolicy discountPolicy) {
        this.tax = taxPolicy.calculateTax(subtotal);
        this.discount = discountPolicy.calculateDiscount(subtotal);
        return subtotal.add(tax.getAmount()).subtract(discount.getAmount());
    }
}

// Fulfillment concerns - changes with operational processes
public class OrderFulfillment {
    private final OrderId orderId;
    private FulfillmentStatus status;
    private ShippingDetails shippingDetails;
    private EstimatedDelivery delivery;
    
    public void updateFulfillmentStatus(FulfillmentStatus newStatus, 
                                      FulfillmentContext context) {
        validateStatusTransition(this.status, newStatus);
        this.status = newStatus;
        this.delivery = context.recalculateDelivery(shippingDetails);
    }
}</code></pre>
                    </div>
                </div>
            </div>

            <div class="subsection">
                <h3>2. Temporal Coupling and SRP</h3>
                <p>When operations must happen in a specific sequence, it often indicates SRP violations:</p>

                <div class="violation-box">
                    <h4>❌ Temporal Coupling Violation</h4>
                    <div class="code-block">
<pre><code>public class PaymentProcessor {
    public PaymentResult processPayment(PaymentRequest request) {
        // Step 1: Validation (changes with business rules)
        validatePaymentMethod(request.getPaymentMethod());
        
        // Step 2: Fraud detection (changes with security policies)
        FraudScore score = calculateFraudScore(request);
        
        // Step 3: Payment processing (changes with gateway APIs)
        PaymentGatewayResponse response = paymentGateway.charge(request);
        
        // Step 4: Reconciliation (changes with accounting requirements)
        createAccountingEntry(request, response);
        
        // Step 5: Notifications (changes with communication preferences)
        sendPaymentConfirmation(request.getCustomerId(), response);
        
        return PaymentResult.from(response);
    }
}</code></pre>
                    </div>
                </div>

                <div class="example-box">
                    <h4>✅ SRP-Compliant Coordination Pattern</h4>
                    <div class="code-block">
<pre><code>public class PaymentOrchestrator {
    private final PaymentValidator validator;
    private final FraudDetectionService fraudDetection;
    private final PaymentGatewayService gatewayService;
    private final AccountingService accountingService;
    private final NotificationService notificationService;
    
    public PaymentResult processPayment(PaymentRequest request) {
        // Each service has a single responsibility
        ValidationResult validation = validator.validate(request);
        if (!validation.isValid()) {
            return PaymentResult.failed(validation.getErrors());
        }
        
        FraudAssessment fraud = fraudDetection.assess(request);
        if (fraud.requiresReview()) {
            return PaymentResult.pending("Under review");
        }
        
        PaymentGatewayResult gatewayResult = gatewayService.processPayment(request);
        if (!gatewayResult.isSuccessful()) {
            return PaymentResult.failed(gatewayResult.getErrorMessage());
        }
        
        // Async operations for non-critical path
        CompletableFuture.runAsync(() -> {
            accountingService.recordTransaction(request, gatewayResult);
            notificationService.sendConfirmations(request, gatewayResult);
        });
        
        return PaymentResult.successful(gatewayResult);
    }
}</code></pre>
                    </div>
                </div>
            </div>

            <div class="benefits-grid">
                <div class="benefit-card">
                    <h4>🎯 Better Maintainability</h4>
                    <p>Changes to specific concerns don't affect other parts of the system, reducing the risk of introducing bugs.</p>
                </div>
                <div class="benefit-card">
                    <h4>🧪 Enhanced Testability</h4>
                    <p>Smaller, focused classes are easier to test in isolation with fewer dependencies and edge cases.</p>
                </div>
                <div class="benefit-card">
                    <h4>🔄 Improved Reusability</h4>
                    <p>Single-purpose components can be reused in different contexts without carrying unnecessary baggage.</p>
                </div>
            </div>
        </section>

        <section id="ocp" class="section">
            <div class="section-header">
                <span class="principle-letter">O</span>
                <div>
                    <h2>Open/Closed Principle</h2>
                    <div class="description">Extension Architectures & Plugin Systems</div>
                </div>
            </div>

            <div class="principle-intro">
                <h3>Advanced OCP Understanding</h3>
                <div class="core-concept">
                    OCP is about creating <span class="highlight">stable abstractions</span> that can accommodate 
                    new requirements through extension rather than modification. It's the foundation for 
                    plugin architectures, strategy patterns, and modular systems.
                </div>
            </div>

            <div class="subsection">
                <h3>1. Plugin Architecture with Dynamic Loading</h3>

                <div class="example-box">
                    <h4>✅ Plugin Contract Definition</h4>
                    <div class="code-block">
<pre><code>public interface PaymentPlugin {
    String getName();
    String getVersion();
    Set&lt;PaymentMethod&gt; getSupportedMethods();
    PaymentResult processPayment(PaymentRequest request);
    PluginConfiguration getConfiguration();
    void initialize(PluginContext context);
    void shutdown();
}

// Plugin metadata for discovery
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface PaymentPluginInfo {
    String name();
    String version();
    String description();
    PaymentMethod[] supportedMethods();
    int priority() default 0;
}</code></pre>
                    </div>
                </div>

                <div class="example-box">
                    <h4>✅ Concrete Plugin Implementation</h4>
                    <div class="code-block">
<pre><code>@PaymentPluginInfo(
    name = "Stripe",
    version = "2.1.0", 
    description = "Stripe payment processing",
    supportedMethods = {PaymentMethod.CREDIT_CARD, PaymentMethod.ACH}
)
public class StripePaymentPlugin extends BasePaymentPlugin {
    private StripeClient stripeClient;
    
    @Override
    protected void doInitialize(PluginContext context) {
        this.stripeConfig = (StripeConfiguration) configuration;
        this.stripeClient = StripeClient.builder()
            .apiKey(stripeConfig.getApiKey())
            .connectTimeout(stripeConfig.getConnectTimeout())
            .build();
    }
    
    @Override
    public PaymentResult processPayment(PaymentRequest request) {
        try {
            StripePaymentRequest stripeRequest = mapToStripeRequest(request);
            StripePaymentResponse response = stripeClient.processPayment(stripeRequest);
            return mapToPaymentResult(response);
        } catch (StripeException e) {
            return PaymentResult.failed(e.getMessage());
        }
    }
}</code></pre>
                    </div>
                </div>
            </div>

            <div class="subsection">
                <h3>2. Strategy Pattern with Functional Extensions</h3>

                <div class="example-box">
                    <h4>✅ Modern Functional Strategy Pattern</h4>
                    <div class="code-block">
<pre><code>@FunctionalInterface
public interface PricingStrategy {
    Money calculatePrice(PricingContext context);
    
    // Default methods for strategy composition
    default PricingStrategy andThen(PricingStrategy after) {
        return context -> after.calculatePrice(
            context.withBasePrice(this.calculatePrice(context))
        );
    }
}

@Component
public class PricingStrategyFactory {
    private final Map&lt;String, PricingStrategy&gt; strategies;
    
    public PricingStrategyFactory() {
        this.strategies = Map.of(
            "STANDARD", this::calculateStandardPrice,
            "PREMIUM", this::calculatePremiumPrice,
            "WHOLESALE", this::calculateWholesalePrice
        );
    }
    
    public PricingStrategy createStrategy(PricingConfiguration config) {
        PricingStrategy baseStrategy = strategies.get(config.getBaseStrategy());
        
        // Compose strategy with modifiers
        PricingStrategy compositeStrategy = baseStrategy;
        for (String modifier : config.getModifiers()) {
            compositeStrategy = compositeStrategy.andThen(getModifier(modifier));
        }
        
        return compositeStrategy;
    }
}</code></pre>
                    </div>
                </div>
            </div>

            <div class="subsection">
                <h3>3. Event-Driven Extension Points</h3>

                <div class="example-box">
                    <h4>✅ Event Handler Framework</h4>
                    <div class="code-block">
<pre><code>public interface EventHandler&lt;T extends DomainEvent&gt; {
    void handle(T event);
    Class&lt;T&gt; getEventType();
    int getPriority();
    default boolean isAsync() { return true; }
}

// Specific event handlers (extensions)
@Component
public class OrderCreatedEmailHandler extends BaseEventHandler&lt;OrderCreatedEvent&gt; {
    private final EmailService emailService;
    
    @Override
    protected void doHandle(OrderCreatedEvent event) {
        Customer customer = customerService.getCustomer(event.getCustomerId());
        emailService.sendOrderConfirmationEmail(customer.getEmail(), event.getOrderId());
    }
    
    @Override
    public int getPriority() {
        return 100; // High priority for customer communication
    }
}

// Domain service publishing events (closed for modification)
@DomainService
public class OrderService {
    private final DomainEventDispatcher eventDispatcher;
    
    @Transactional
    public OrderId createOrder(CreateOrderCommand command) {
        Order order = Order.create(command);
        Order savedOrder = orderRepository.save(order);
        
        // Publish domain event for extensions
        OrderCreatedEvent event = new OrderCreatedEvent(
            savedOrder.getId(), savedOrder.getCustomerId(), savedOrder.getTotalAmount()
        );
        
        eventDispatcher.dispatch(event);
        return savedOrder.getId();
    }
}</code></pre>
                    </div>
                </div>
            </div>

            <div class="benefits-grid">
                <div class="benefit-card">
                    <h4>🔧 Easy Extension</h4>
                    <p>New features can be added through plugins and extensions without modifying existing code.</p>
                </div>
                <div class="benefit-card">
                    <h4>🛡️ Stability</h4>
                    <p>Core functionality remains stable while new capabilities are added through well-defined extension points.</p>
                </div>
                <div class="benefit-card">
                    <h4>🏗️ Modularity</h4>
                    <p>System components can be developed, tested, and deployed independently.</p>
                </div>
            </div>
        </section>

        <section id="lsp" class="section">
            <div class="section-header">
                <span class="principle-letter">L</span>
                <div>
                    <h2>Liskov Substitution Principle</h2>
                    <div class="description">Behavioral Contracts & Semantic Consistency</div>
                </div>
            </div>

            <div class="principle-intro">
                <h3>Advanced LSP Understanding</h3>
                <div class="core-concept">
                    LSP is fundamentally about <span class="highlight">behavioral subtyping</span>. 
                    It's not enough for subclasses to have the same method signatures; 
                    they must preserve the semantic contracts of their base classes.
                </div>
            </div>

            <div class="subsection">
                <h3>1. Behavioral Contract Violations</h3>

                <div class="violation-box">
                    <h4>❌ Contract Violation - Strengthened Preconditions</h4>
                    <div class="code-block">
<pre><code>public abstract class FileProcessor {
    /**
     * Processes a file and returns the result.
     * Preconditions: File must exist and be readable, size < 100MB
     * Postconditions: Returns non-null result, completes within 30 seconds
     */
    public abstract ProcessingResult process(File file) 
        throws ProcessingException, SecurityException;
}

// LSP violation - strengthened preconditions
public class StrictXmlProcessor extends FileProcessor {
    @Override
    public ProcessingResult process(File file) throws ProcessingException {
        validateFile(file);
        
        // LSP violation - additional requirement not in base contract
        if (!file.getName().endsWith(".xml")) {
            throw new IllegalArgumentException("Only XML files supported");
        }
        
        // LSP violation - requires specific encoding
        if (!hasUtf8Encoding(file)) {
            throw new ProcessingException("File must be UTF-8 encoded");
        }
        
        return processXmlWithValidation(file);
    }
}</code></pre>
                    </div>
                </div>

                <div class="example-box">
                    <h4>✅ LSP-Compliant Implementation</h4>
                    <div class="code-block">
<pre><code>public class XmlFileProcessor extends FileProcessor {
    @Override
    public ProcessingResult process(File file) throws ProcessingException {
        validateFile(file);
        
        // Weakened precondition - accepts any file, checks format internally
        if (!isXmlFile(file)) {
            throw new ProcessingException("File format not supported by XML processor");
        }
        
        try {
            return processXmlFile(file);
        } catch (XmlParsingException e) {
            // Maintains exception contract
            throw new ProcessingException("XML parsing failed: " + e.getMessage(), e);
        }
    }
    
    private ProcessingResult processXmlFile(File file) {
        // Ensures processing completes within time contract
        return executeWithTimeout(() -> doXmlProcessing(file), Duration.ofSeconds(30));
    }
}</code></pre>
                    </div>
                </div>
            </div>

            <div class="subsection">
                <h3>2. Performance Contract Compliance</h3>

                <div class="example-box">
                    <h4>✅ Repository with Performance Contracts</h4>
                    <div class="code-block">
<pre><code>public interface UserRepository {
    /**
     * Performance contract: O(1) operation, completes within 100ms
     */
    Optional&lt;User&gt; findById(Long id);
    
    /**
     * Performance contract: O(log n) operation, completes within 500ms
     */
    List&lt;User&gt; findByEmail(String email);
}

// LSP-compliant database implementation with caching
@Repository
public class CachedDatabaseUserRepository implements UserRepository {
    private final Cache&lt;Long, User&gt; userCache;
    
    @Override
    public Optional&lt;User&gt; findById(Long id) {
        // Check cache first - maintains O(1) performance contract
        User cachedUser = userCache.getIfPresent(id);
        if (cachedUser != null) {
            return Optional.of(cachedUser);
        }
        
        // Database lookup with timeout to ensure performance contract
        Optional&lt;User&gt; user = executeWithTimeout(
            () -> findUserByIdFromDatabase(id),
            Duration.ofMillis(100)
        );
        
        user.ifPresent(u -> userCache.put(id, u));
        return user;
    }
}</code></pre>
                    </div>
                </div>
            </div>

            <div class="benefits-grid">
                <div class="benefit-card">
                    <h4>🔄 Safe Substitution</h4>
                    <p>Any subclass can replace its parent without breaking client code expectations.</p>
                </div>
                <div class="benefit-card">
                    <h4>📋 Contract Clarity</h4>
                    <p>Clear behavioral contracts make system behavior predictable and reliable.</p>
                </div>
                <div class="benefit-card">
                    <h4>🎯 Polymorphism</h4>
                    <p>Enables true polymorphism where different implementations can be used interchangeably.</p>
                </div>
            </div>
        </section>

        <section id="isp" class="section">
            <div class="section-header">
                <span class="principle-letter">I</span>
                <div>
                    <h2>Interface Segregation Principle</h2>
                    <div class="description">Client-Centric Design & Role-Based Interfaces</div>
                </div>
            </div>

            <div class="principle-intro">
                <h3>Advanced ISP Understanding</h3>
                <div class="core-concept">
                    ISP is about <span class="highlight">client-centric design</span>. 
                    Interfaces should be designed from the perspective of their clients, 
                    not their implementations, leading to better decoupling and maintainability.
                </div>
            </div>

            <div class="subsection">
                <h3>1. Role-Based Interface Segregation</h3>

                <div class="violation-box">
                    <h4>❌ Monolithic Interface Violation</h4>
                    <div class="code-block">
<pre><code>public interface UserManagementSystem {
    // User CRUD operations
    User createUser(CreateUserRequest request);
    User updateUser(Long id, UpdateUserRequest request);
    void deleteUser(Long id);
    
    // User authentication
    AuthenticationResult authenticate(String username, String password);
    void resetPassword(Long userId);
    
    // User permissions
    void grantPermission(Long userId, Permission permission);
    List&lt;Permission&gt; getUserPermissions(Long userId);
    
    // User analytics
    UserAnalytics getUserAnalytics(Long userId);
    List&lt;UserActivity&gt; getUserActivity(Long userId, DateRange range);
    
    // User notifications
    void sendNotification(Long userId, Notification notification);
    List&lt;Notification&gt; getUserNotifications(Long userId);
    
    // Bulk operations
    BulkOperationResult bulkCreateUsers(List&lt;CreateUserRequest&gt; requests);
    void exportUsers(ExportFormat format, OutputStream output);
}</code></pre>
                    </div>
                </div>

                <div class="example-box">
                    <h4>✅ ISP-Compliant Role-Based Interfaces</h4>
                    <div class="code-block">
<pre><code>// Segregated interfaces based on client needs
public interface UserRepository {
    User save(User user);
    Optional&lt;User&gt; findById(Long id);
    void delete(Long id);
}

public interface UserQueryService {
    Optional&lt;User&gt; getUserById(Long id);
    List&lt;User&gt; searchUsers(UserSearchCriteria criteria);
}

public interface UserCommandService {
    User createUser(CreateUserCommand command);
    User updateUser(UpdateUserCommand command);
    void deleteUser(DeleteUserCommand command);
}

public interface UserAuthenticationService {
    AuthenticationResult authenticate(AuthenticationRequest request);
    void resetPassword(PasswordResetRequest request);
    TokenValidationResult validateToken(String token);
}

// Client-specific composition interfaces
public interface AdminUserOperations extends UserQueryService, UserCommandService, 
                                           UserPermissionService {
    // Admin-specific combined operations
    default AdminUserSummary getAdminUserSummary(Long userId) {
        User user = getUserById(userId).orElseThrow();
        Set&lt;Permission&gt; permissions = getUserPermissions(userId);
        return AdminUserSummary.of(user, permissions);
    }
}

public interface CustomerSelfServiceOperations extends UserPreferenceService, 
                                                     UserNotificationService {
    // Customer self-service operations only
}</code></pre>
                    </div>
                </div>
            </div>

            <div class="subsection">
                <h3>2. Command-Query Interface Segregation</h3>

                <div class="example-box">
                    <h4>✅ Segregated Command and Query Interfaces</h4>
                    <div class="code-block">
<pre><code>// Command interfaces - for write operations
public interface OrderCommands {
    OrderId createOrder(CreateOrderCommand command);
    void updateOrder(UpdateOrderCommand command);
    void cancelOrder(CancelOrderCommand command);
}

// Query interfaces - for read operations
public interface OrderQueries {
    Optional&lt;OrderView&gt; getOrderById(OrderId orderId);
    List&lt;OrderSummary&gt; getOrdersByCustomer(CustomerId customerId);
    PagedResult&lt;OrderSummary&gt; searchOrders(OrderSearchCriteria criteria);
}

public interface OrderAnalyticsQueries {
    OrderAnalytics getOrderAnalytics(OrderId orderId);
    List&lt;OrderTrend&gt; getOrderTrends(DateRange dateRange);
    SalesMetrics getSalesMetrics(SalesMetricsRequest request);
}

// Client-specific aggregated interfaces
public interface OrderManagementService extends OrderCommands, OrderQueries {
    // Management operations combining commands and queries
}

public interface OrderReportingService extends OrderQueries, OrderAnalyticsQueries {
    // Reporting operations - read-only
}</code></pre>
                    </div>
                </div>
            </div>

            <div class="benefits-grid">
                <div class="benefit-card">
                    <h4>🎯 Focused Dependencies</h4>
                    <p>Clients only depend on the methods they actually use, reducing coupling and complexity.</p>
                </div>
                <div class="benefit-card">
                    <h4>🔒 Security</h4>
                    <p>Role-based interfaces naturally enforce security boundaries and access control.</p>
                </div>
                <div class="benefit-card">
                    <h4>⚡ Performance</h4>
                    <p>Smaller interfaces can be optimized for specific use cases and access patterns.</p>
                </div>
            </div>
        </section>

        <section id="dip" class="section">
            <div class="section-header">
                <span class="principle-letter">D</span>
                <div>
                    <h2>Dependency Inversion Principle</h2>
                    <div class="description">Architectural Boundaries & Control Flow</div>
                </div>
            </div>

            <div class="principle-intro">
                <h3>Advanced DIP Understanding</h3>
                <div class="core-concept">
                    DIP is fundamentally about <span class="highlight">architectural control flow</span>. 
                    It inverts the traditional dependency direction to create flexible, testable, 
                    and maintainable systems where business logic is insulated from implementation details.
                </div>
            </div>

            <div class="subsection">
                <h3>1. Hexagonal Architecture with DIP</h3>

                <div class="example-box">
                    <h4>✅ Domain Layer Defining Abstractions</h4>
                    <div class="code-block">
<pre><code>// Domain layer (high-level) - defines abstractions
public interface UserRepository {
    User save(User user);
    Optional&lt;User&gt; findById(UserId id);
    List&lt;User&gt; findByEmail(String email);
}

public interface EmailService {
    void sendEmail(EmailMessage message);
    EmailDeliveryStatus getDeliveryStatus(String messageId);
}

// Domain service (high-level) depending only on abstractions
@DomainService
public class UserRegistrationService {
    private final UserRepository userRepository;
    private final EmailService emailService;
    private final EventPublisher eventPublisher;
    
    public UserRegistrationResult registerUser(UserRegistrationRequest request) {
        // Validate business rules
        validateRegistrationRequest(request);
        
        // Create domain entity
        User user = User.builder()
            .email(request.getEmail())
            .firstName(request.getFirstName())
            .lastName(request.getLastName())
            .build();
            
        // Save user through abstraction
        User savedUser = userRepository.save(user);
        
        // Send welcome email through abstraction
        EmailMessage welcomeMessage = EmailMessage.builder()
            .to(savedUser.getEmail())
            .subject("Welcome!")
            .template("welcome-template")
            .build();
        emailService.sendEmail(welcomeMessage);
        
        // Publish domain event
        eventPublisher.publish(new UserRegisteredEvent(savedUser.getId()));
        
        return UserRegistrationResult.success(savedUser.getId());
    }
}</code></pre>
                    </div>
                </div>

                <div class="example-box">
                    <h4>✅ Infrastructure Layer Implementation</h4>
                    <div class="code-block">
<pre><code>// Infrastructure layer (low-level) - implements abstractions
@Repository
public class JpaUserRepository implements UserRepository {
    private final UserJpaRepository jpaRepository;
    private final UserMapper userMapper;
    
    @Override
    public User save(User user) {
        UserEntity entity = userMapper.toEntity(user);
        UserEntity saved = jpaRepository.save(entity);
        return userMapper.toDomain(saved);
    }
    
    @Override
    public Optional&lt;User&gt; findById(UserId id) {
        return jpaRepository.findById(id.getValue())
            .map(userMapper::toDomain);
    }
}

@Component
public class SmtpEmailService implements EmailService {
    private final JavaMailSender mailSender;
    private final TemplateEngine templateEngine;
    
    @Override
    public void sendEmail(EmailMessage message) {
        try {
            MimeMessage mimeMessage = mailSender.createMimeMessage();
            MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true);
            
            helper.setTo(message.getTo());
            helper.setSubject(message.getSubject());
            
            String htmlContent = templateEngine.process(
                message.getTemplate(), 
                createTemplateContext(message.getData())
            );
            helper.setText(htmlContent, true);
            
            mailSender.send(mimeMessage);
        } catch (MessagingException e) {
            throw new EmailDeliveryException("Failed to send email", e);
        }
    }
}</code></pre>
                    </div>
                </div>
            </div>

            <div class="subsection">
                <h3>2. Configuration-Based Dependency Injection</h3>

                <div class="example-box">
                    <h4>✅ Environment-Specific Configurations</h4>
                    <div class="code-block">
<pre><code>@Configuration
@Profile("development")
public class DevelopmentConfiguration {
    
    @Bean
    @Primary
    public UserRepository userRepository() {
        return new InMemoryUserRepository();
    }
    
    @Bean
    @Primary
    public EmailService emailService() {
        return new MockEmailService();
    }
    
    @Bean
    @Primary
    public PaymentGateway paymentGateway() {
        return new MockPaymentGateway();
    }
}

@Configuration
@Profile("production")
public class ProductionConfiguration {
    
    @Bean
    @Primary
    public UserRepository userRepository(
            UserJpaRepository jpaRepository,
            RedisTemplate&lt;String, Object&gt; redisTemplate) {
        return new CachedUserRepository(
            new JpaUserRepository(jpaRepository),
            redisTemplate
        );
    }
    
    @Bean
    @Primary
    public PaymentGateway paymentGateway(
            @Value("${payment.provider}") String provider,
            StripeApiClient stripeClient,
            PayPalApiClient paypalClient) {
        
        return switch (provider.toLowerCase()) {
            case "stripe" -> new StripePaymentGateway(stripeClient);
            case "paypal" -> new PayPalPaymentGateway(paypalClient);
            default -> throw new IllegalArgumentException("Unknown provider: " + provider);
        };
    }
}</code></pre>
                    </div>
                </div>
            </div>

            <div class="benefits-grid">
                <div class="benefit-card">
                    <h4>🧪 Testability</h4>
                    <p>Easy to substitute mock implementations for testing without changing business logic.</p>
                </div>
                <div class="benefit-card">
                    <h4>🔧 Flexibility</h4>
                    <p>Runtime configuration of dependencies allows for different environments and deployment scenarios.</p>
                </div>
                <div class="benefit-card">
                    <h4>🛡️ Isolation</h4>
                    <p>Business logic is completely isolated from implementation details and external dependencies.</p>
                </div>
            </div>
        </section>

        <section id="distributed-systems" class="section">
            <div class="section-header">
                <h2>🌐 SOLID in Distributed Systems</h2>
                <div class="description">Applying SOLID principles in microservices and distributed architectures</div>
            </div>

            <div class="subsection">
                <h3>Service Boundaries and SRP</h3>
                <p>In microservices, each service should have a single business responsibility:</p>

                <div class="example-box">
                    <h4>✅ SRP-Compliant Microservice Design</h4>
                    <div class="code-block">
<pre><code>// User Management Service - Single responsibility: User lifecycle
@RestController
@RequestMapping("/api/v1/users")
public class UserManagementController {
    private final UserManagementService userService;
    private final DomainEventPublisher eventPublisher;
    
    @PostMapping
    public ResponseEntity&lt;UserResponse&gt; createUser(@RequestBody CreateUserRequest request) {
        User user = userService.createUser(CreateUserCommand.from(request));
        
        // Publish event for other services
        eventPublisher.publish(new UserCreatedEvent(user.getId(), user.getEmail()));
        
        return ResponseEntity.ok(UserResponse.from(user));
    }
}

// Notification Service - Single responsibility: Communications
@Component
public class UserNotificationEventHandler {
    private final EmailService emailService;
    
    @EventHandler
    public void handleUserCreated(UserCreatedEvent event) {
        emailService.sendWelcomeEmail(event.getEmail());
    }
}

// Analytics Service - Single responsibility: Data analysis
@Component
public class UserAnalyticsEventHandler {
    private final AnalyticsService analyticsService;
    
    @EventHandler
    public void handleUserCreated(UserCreatedEvent event) {
        analyticsService.trackEvent("user_registration", Map.of(
            "userId", event.getUserId(),
            "timestamp", event.getTimestamp()
        ));
    }
}</code></pre>
                    </div>
                </div>
            </div>

            <div class="subsection">
                <h3>API Versioning with OCP</h3>

                <div class="example-box">
                    <h4>✅ Extension-Based API Versioning</h4>
                    <div class="code-block">
<pre><code>// Base API contract
public interface OrderApiContract {
    ResponseEntity&lt;OrderResponse&gt; createOrder(CreateOrderRequest request);
    ResponseEntity&lt;OrderResponse&gt; getOrder(Long orderId);
}

// Version 1 implementation
@RestController
@RequestMapping("/api/v1/orders")
public class OrderControllerV1 implements OrderApiContract {
    
    @Override
    @PostMapping
    public ResponseEntity&lt;OrderResponse&gt; createOrder(@RequestBody CreateOrderRequest request) {
        Order order = orderService.createOrder(mapToCommand(request));
        return ResponseEntity.ok(mapToResponse(order));
    }
}

// Version 2 implementation (extended functionality)
@RestController
@RequestMapping("/api/v2/orders")
public class OrderControllerV2 implements OrderApiContract {
    
    @Override
    @PostMapping
    public ResponseEntity&lt;OrderResponse&gt; createOrder(@RequestBody CreateOrderRequestV2 request) {
        // V2 supports payment processing during order creation
        Order order = orderService.createOrder(mapToCommandV2(request));
        
        if (request.getPaymentDetails() != null) {
            PaymentResult payment = paymentService.processPayment(order.getId(), request.getPaymentDetails());
            order.updatePaymentStatus(payment.getStatus());
        }
        
        return ResponseEntity.ok(mapToResponseV2(order));
    }
    
    // Additional V2 endpoints
    @GetMapping("/{orderId}/tracking")
    public ResponseEntity&lt;OrderTrackingResponse&gt; getOrderTracking(@PathVariable Long orderId) {
        OrderTracking tracking = shippingService.getOrderTracking(orderId);
        return ResponseEntity.ok(OrderTrackingResponse.from(tracking));
    }
}</code></pre>
                    </div>
                </div>
            </div>
        </section>

        <section id="testing-strategies" class="section">
            <div class="section-header">
                <h2>🧪 Testing Strategies with SOLID</h2>
                <div class="description">How SOLID principles enable comprehensive testing strategies</div>
            </div>

            <div class="subsection">
                <h3>Dependency Injection for Testing</h3>

                <div class="example-box">
                    <h4>✅ DIP Enables Easy Mocking</h4>
                    <div class="code-block">
<pre><code>@ExtendWith(MockitoExtension.class)
class UserRegistrationServiceTest {
    
    @Mock private UserRepository userRepository;
    @Mock private EmailService emailService;
    @Mock private EventPublisher eventPublisher;
    
    private UserRegistrationService service;
    
    @BeforeEach
    void setUp() {
        // DIP allows easy injection of mocks
        service = new UserRegistrationService(userRepository, emailService, eventPublisher);
    }
    
    @Test
    void shouldRegisterUserSuccessfully() {
        // Given
        UserRegistrationRequest request = UserRegistrationRequest.builder()
            .email("test@example.com")
            .firstName("John")
            .lastName("Doe")
            .build();
            
        User expectedUser = User.builder()
            .id(UserId.of(1L))
            .email("test@example.com")
            .firstName("John")
            .lastName("Doe")
            .build();
        
        when(userRepository.save(any(User.class))).thenReturn(expectedUser);
        
        // When
        UserRegistrationResult result = service.registerUser(request);
        
        // Then
        assertThat(result.isSuccess()).isTrue();
        assertThat(result.getUserId()).isEqualTo(expectedUser.getId());
        
        verify(emailService).sendEmail(any(EmailMessage.class));
        verify(eventPublisher).publish(any(UserRegisteredEvent.class));
    }
    
    @Test
    void shouldFailWhenUserAlreadyExists() {
        // Given
        UserRegistrationRequest request = createValidRequest();
        when(userRepository.findByEmail(request.getEmail()))
            .thenReturn(List.of(existingUser));
        
        // When & Then
        assertThatThrownBy(() -> service.registerUser(request))
            .isInstanceOf(UserAlreadyExistsException.class);
            
        verify(userRepository, never()).save(any(User.class));
        verify(emailService, never()).sendEmail(any(EmailMessage.class));
    }
}</code></pre>
                    </div>
                </div>
            </div>

            <div class="subsection">
                <h3>LSP Compliance Testing</h3>

                <div class="example-box">
                    <h4>✅ Abstract Base Test for LSP Verification</h4>
                    <div class="code-block">
<pre><code>// Base test class for LSP compliance verification
public abstract class PaymentMethodLSPTest {
    
    protected abstract PaymentMethod createValidPaymentMethod();
    protected abstract Money getValidAmount();
    protected abstract String getValidTransactionId();
    
    @Test
    public void processPayment_withValidInputs_shouldReturnNonNullResult() {
        // LSP test: all implementations must return non-null result
        PaymentMethod paymentMethod = createValidPaymentMethod();
        Money amount = getValidAmount();
        String transactionId = getValidTransactionId();
        
        PaymentResult result = paymentMethod.processPayment(amount, transactionId);
        
        assertThat(result).isNotNull();
    }
    
    @Test
    public void processPayment_withNegativeAmount_shouldThrowException() {
        // LSP test: all implementations must reject negative amounts
        PaymentMethod paymentMethod = createValidPaymentMethod();
        Money negativeAmount = Money.of(-10, "USD");
        
        assertThatThrownBy(() -> 
            paymentMethod.processPayment(negativeAmount, getValidTransactionId()))
            .isInstanceOf(IllegalArgumentException.class);
    }
}

// Specific implementation tests
public class CreditCardLSPTest extends PaymentMethodLSPTest {
    
    @Override
    protected PaymentMethod createValidPaymentMethod() {
        return CreditCard.builder()
            .cardNumber("4111111111111111")
            .expiryDate("12/2025")
            .cvv("123")
            .cardholderName("John Doe")
            .build();
    }
    
    @Override
    protected Money getValidAmount() {
        return Money.of(100, "USD");
    }
    
    @Override
    protected String getValidTransactionId() {
        return "TXN_" + System.currentTimeMillis();
    }
}</code></pre>
                    </div>
                </div>
            </div>
        </section>

        <section id="performance" class="section">
            <div class="section-header">
                <h2>⚡ Performance Considerations</h2>
                <div class="description">Balancing SOLID principles with performance requirements</div>
            </div>

            <div class="subsection">
                <h3>Performance-Conscious SOLID Design</h3>

                <div class="example-box">
                    <h4>✅ Caching Strategy with SOLID Compliance</h4>
                    <div class="code-block">
<pre><code>// Interface segregation for different caching strategies
public interface CachingStrategy&lt;K, V&gt; {
    Optional&lt;V&gt; get(K key);
    void put(K key, V value);
    void evict(K key);
    void clear();
}

// OCP-compliant implementation
@Component
public class LRUCachingStrategy&lt;K, V&gt; implements CachingStrategy&lt;K, V&gt; {
    private final LinkedHashMap&lt;K, V&gt; cache;
    private final int maxSize;
    
    public LRUCachingStrategy(@Value("${cache.max-size:1000}") int maxSize) {
        this.maxSize = maxSize;
        this.cache = new LinkedHashMap&lt;K, V&gt;(16, 0.75f, true) {
            @Override
            protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) {
                return size() > maxSize;
            }
        };
    }
    
    @Override
    public synchronized Optional&lt;V&gt; get(K key) {
        return Optional.ofNullable(cache.get(key));
    }
    
    @Override
    public synchronized void put(K key, V value) {
        cache.put(key, value);
    }
}

// Repository with performance-optimized design following DIP
@Repository
public class CachedUserRepository implements UserRepository {
    private final UserRepository delegate;
    private final CachingStrategy&lt;Long, User&gt; cache;
    private final MetricRegistry metrics;
    
    @Override
    public Optional&lt;User&gt; findById(Long id) {
        Timer.Context timer = metrics.timer("user.repository.findById").time();
        try {
            return cache.get(id)
                .map(user -> {
                    metrics.counter("user.repository.cache.hit").inc();
                    return Optional.of(user);
                })
                .orElseGet(() -> {
                    metrics.counter("user.repository.cache.miss").inc();
                    Optional&lt;User&gt; user = delegate.findById(id);
                    user.ifPresent(u -> cache.put(id, u));
                    return user;
                });
        } finally {
            timer.stop();
        }
    }
}</code></pre>
                    </div>
                </div>
            </div>

            <div class="key-points">
                <h4>🎯 Performance vs SOLID Trade-offs</h4>
                <ul>
                    <li><strong>Abstraction Overhead:</strong> Use profiling to identify where abstraction layers add significant overhead</li>
                    <li><strong>Caching Strategies:</strong> Implement caching at the appropriate abstraction level</li>
                    <li><strong>Batch Operations:</strong> Design interfaces to support both single and batch operations</li>
                    <li><strong>Lazy Loading:</strong> Use dependency injection to enable lazy initialization</li>
                </ul>
            </div>
        </section>

        <section id="anti-patterns" class="section">
            <div class="section-header">
                <h2>🚫 Anti-Patterns & Common Violations</h2>
                <div class="description">Recognizing and avoiding SOLID principle violations</div>
            </div>

            <div class="subsection">
                <h3>The God Object Anti-Pattern</h3>

                <div class="violation-box">
                    <h4>❌ Massive SRP and ISP Violation</h4>
                    <div class="code-block">
<pre><code>public class ApplicationManager {
    // Database management
    private DataSource dataSource;
    public void configureDatabase() { /* */ }
    public Connection getConnection() { /* */ }
    
    // User management  
    private List&lt;User&gt; users;
    public User createUser(UserDto dto) { /* */ }
    public void deleteUser(Long id) { /* */ }
    
    // Email services
    private EmailConfiguration emailConfig;
    public void sendEmail(String to, String subject, String body) { /* */ }
    
    // File operations
    public void uploadFile(MultipartFile file) { /* */ }
    public byte[] downloadFile(String filename) { /* */ }
    
    // Caching, Security, Configuration, Logging...
    // This class violates multiple SOLID principles!
}</code></pre>
                    </div>
                </div>

                <div class="example-box">
                    <h4>✅ Refactoring Strategy: Extract Services</h4>
                    <div class="code-block">
<pre><code>// SRP-compliant services
@Component
public class UserService {
    private final UserRepository userRepository;
    private final UserValidator userValidator;
    private final DomainEventPublisher eventPublisher;
    
    public User createUser(CreateUserCommand command) {
        userValidator.validate(command);
        User user = User.create(command);
        User savedUser = userRepository.save(user);
        eventPublisher.publish(new UserCreatedEvent(savedUser));
        return savedUser;
    }
}

@Component  
public class EmailService {
    private final EmailSender emailSender;
    private final TemplateEngine templateEngine;
    
    public void sendEmail(EmailRequest request) {
        String content = templateEngine.process(request.getTemplate(), request.getData());
        emailSender.send(request.getRecipient(), request.getSubject(), content);
    }
}

// Facade pattern for simplified client interface
@Component
public class ApplicationFacade {
    private final UserService userService;
    private final EmailService emailService;
    private final FileService fileService;
    
    public void registerNewUser(UserRegistrationRequest request) {
        User user = userService.createUser(request.toCreateCommand());
        emailService.sendWelcomeEmail(user);
    }
}</code></pre>
                    </div>
                </div>
            </div>

            <div class="subsection">
                <h3>Violation Recovery Strategies</h3>

                <div class="key-points">
                    <h4>🔧 Refactoring Approach</h4>
                    <ul>
                        <li><strong>Identify Responsibilities:</strong> List all the different reasons a class might change</li>
                        <li><strong>Extract Services:</strong> Create focused services for each responsibility</li>
                        <li><strong>Introduce Abstractions:</strong> Define interfaces for external dependencies</li>
                        <li><strong>Apply Dependency Injection:</strong> Use IoC container for dependency management</li>
                        <li><strong>Create Facades:</strong> Provide simplified interfaces for complex subsystems</li>
                    </ul>
                </div>
            </div>
        </section>

        <section id="conclusion" class="section">
            <div class="summary-section">
                <h2>🎯 Conclusion & Best Practices</h2>
                <p>For senior developers, SOLID principles represent more than coding guidelines—they're architectural thinking tools that guide system evolution and team collaboration.</p>

                <div class="summary-grid">
                    <div class="summary-card">
                        <h3>📈 Strategic Application</h3>
                        <p>Apply SOLID principles contextually. Not every piece of code needs the full SOLID treatment, but architectural boundaries should rigorously follow these principles.</p>
                    </div>
                    <div class="summary-card">
                        <h3>🔄 Evolution & Refactoring</h3>
                        <p>Use SOLID principles as a guide for system evolution. When extending functionality, OCP guides extension strategies. When code becomes unwieldy, SRP guides decomposition.</p>
                    </div>
                    <div class="summary-card">
                        <h3>👥 Team Communication</h3>
                        <p>SOLID principles provide a shared vocabulary for design discussions. They help communicate design intent and trade-offs to team members and stakeholders.</p>
                    </div>
                    <div class="summary-card">
                        <h3>⚡ Performance Balance</h3>
                        <p>While SOLID principles promote good design, they shouldn't be applied blindly at the expense of performance. Use profiling data to guide decisions about when abstraction layers add value versus overhead.</p>
                    </div>
                    <div class="summary-card">
                        <h3>🏗️ Modern Architecture</h3>
                        <p>In microservices, event-driven architectures, and cloud-native applications, SOLID principles help define service boundaries, event contracts, and integration patterns.</p>
                    </div>
                </div>

                <div style="margin-top: 40px; padding: 30px; background: rgba(255,255,255,0.1); border-radius: 15px;">
                    <h3 style="text-align: center; margin-bottom: 20px;">🎖️ Mastery of SOLID Principles</h3>
                    <p style="text-align: center; font-size: 1.2em; line-height: 1.8;">
                        The mastery of SOLID principles lies not in rigid adherence but in understanding 
                        <strong>when and how</strong> to apply them to create systems that are 
                        <strong>maintainable</strong>, <strong>testable</strong>, and <strong>evolvable</strong> over time.
                    </p>
                </div>
            </div>
        </section>
    </div>

    <script>
        // Smooth scrolling for navigation links
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });

        // Scroll progress indicator
        function updateScrollProgress() {
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const scrollHeight = document.documentElement.scrollHeight - window.innerHeight;
            const progress = (scrollTop / scrollHeight) * 100;
            document.getElementById('scrollProgress').style.width = progress + '%';
        }

        window.addEventListener('scroll', updateScrollProgress);

        // Hide navigation on small screens when scrolling
        let lastScrollTop = 0;
        window.addEventListener('scroll', function() {
            const currentScrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const navigation = document.getElementById('navigation');
            
            if (window.innerWidth <= 768) {
                if (currentScrollTop > lastScrollTop && currentScrollTop > 100) {
                    navigation.style.transform = 'translateX(100%)';
                } else {
                    navigation.style.transform = 'translateX(0)';
                }
            }
            lastScrollTop = currentScrollTop;
        });

        // Add syntax highlighting effect
        document.querySelectorAll('.code-block code').forEach(block => {
            const text = block.textContent;
            
            // Simple syntax highlighting for Java keywords
            const highlighted = text
                .replace(/\b(public|private|protected|class|interface|extends|implements|abstract|final|static|void|return|if|else|for|while|try|catch|throw|throws|new|this|super|import|package|@Override|@Component|@Service|@Repository|@Autowired)\b/g, '<span style="color: #569cd6;">$1</span>')
                .replace(/\b(String|Integer|Long|Boolean|List|Map|Set|Optional|Stream)\b/g, '<span style="color: #4ec9b0;">$1</span>')
                .replace(/"([^"]*)"/g, '<span style="color: #ce9178;">"$1"</span>')
                .replace(/\/\*[\s\S]*?\*\//g, '<span style="color: #6a9955;">            <div class="subsection">
                <h3>Performance-</span>')
                .replace(/\/\/.*$/gm, '<span style="color: #6a9955;">            <div class="subsection">
                <h3>Performance-</span>');
            
            block.innerHTML = highlighted;
        });

        // Add animation to cards on scroll
        const observerOptions = {
            threshold: 0.1,
            rootMargin: '0px 0px -100px 0px'
        };

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.style.opacity = '1';
                    entry.target.style.transform = 'translateY(0)';
                }
            });
        }, observerOptions);

        // Observe cards for animation
        document.querySelectorAll('.benefit-card, .principle-card, .summary-card').forEach(card => {
            card.style.opacity = '0';
            card.style.transform = 'translateY(20px)';
            card.style.transition = 'opacity 0.6s ease, transform 0.6s ease';
            observer.observe(card);
        });

        // Print functionality
        function printPresentation() {
            window.print();
        }

        // Add print button
        const printButton = document.createElement('button');
        printButton.textContent = '🖨️ Print';
        printButton.style.cssText = `
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #3498db;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 1000;
            transition: all 0.3s ease;
        `;
        
        printButton.addEventListener('mouseover', () => {
            printButton.style.background = '#2980b9';
            printButton.style.transform = 'translateY(-2px)';
        });
        
        printButton.addEventListener('mouseout', () => {
            printButton.style.background = '#3498db';
            printButton.style.transform = 'translateY(0)';
        });
        
        printButton.addEventListener('click', printPresentation);
        document.body.appendChild(printButton);

        // Responsive navigation toggle
        function createMobileNav() {
            if (window.innerWidth <= 768) {
                const mobileNavToggle = document.createElement('button');
                mobileNavToggle.innerHTML = '☰';
                mobileNavToggle.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: rgba(44, 62, 80, 0.9);
                    color: white;
                    border: none;
                    padding: 15px;
                    border-radius: 50%;
                    cursor: pointer;
                    font-size: 18px;
                    z-index: 1001;
                    width: 50px;
                    height: 50px;
                `;
                
                mobileNavToggle.addEventListener('click', () => {
                    const nav = document.getElementById('navigation');
                    const isVisible = nav.style.display !== 'none';
                    nav.style.display = isVisible ? 'none' : 'block';
                });
                
                document.body.appendChild(mobileNavToggle);
            }
        }

        window.addEventListener('resize', createMobileNav);
        createMobileNav();
    </script>

    <style media="print">
        .navigation, .scroll-indicator, button {
            display: none !important;
        }
        
        .container {
            box-shadow: none !important;
            margin: 0 !important;
            padding: 20px !important;
        }
        
        .section {
            page-break-inside: avoid;
            margin-bottom: 40px;
        }
        
        .code-block {
            page-break-inside: avoid;
            font-size: 10px !important;
        }
        
        .header {
            page-break-after: always;
        }
        
        body {
            background: white !important;
        }
    </style>
</body>
</html>
